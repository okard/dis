%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Syntax/Grammar
\section{Syntax / Grammar}

 
\subsection{Types}
Built-in:
\begin{multicols}{4}
\begin{itemize}
\item bool 
\item byte 
\item ubyte 
\item short 
\item ushort 
\item int 
\item uint 
\item long 
\item ulong 
\item float 
\item double 
\item ptr 
\item char 
\end{itemize}
\end{multicols}

User defined types:
\begin{itemize}
\item Classes, 
\item Functions, 
\item Traits, 
\item Structures
\item Enums
\item Delegates
\item Alias
\item Variants
\end{itemize}

\subsection{Declarations}

\subsubsection{Packages}

\begin{ebnf}
PackageDeclaration & \rightarrow "package" identifier\; \\
\end{ebnf}

\subsubsection{Types}

\begin{itemize}
\item Identifier
\item Identifier.Identifier
\item Identifier[]
\item Identifier!Identifier
\item Identifier!(Identifier, Identifier)
\item {[}Identifier]
\item Identifier *
\item ref Type
\item ptr Type
\end{itemize}

%% Variables %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Variables \& Values}
\begin{ebnf}
	VariableDecl & \rightarrow "var"\; Identfifier\; [":"\; TypeIdentifier] ["=" Literal] (";" | CRLF) \\
	ValueDecl & \rightarrow "val"\; Identfifier\; [":"\; TypeIdentifier] ["=" Literal] (";" | CRLF)
\end{ebnf}

\begin{lstlisting}
// Explicit Typing
var i : int = 5;
val f : float = 5.0;
// Implicit Typing
var i = 5;
var b = 0x0;

\end{lstlisting}

\subsubsection{Constants}
\begin{ebnf}
	ConstantDecl & \rightarrow "const"\; Identfifier\; [":"\; TypeIdentifier] ["=" Literal] (";" | CRLF) \\
\end{ebnf}

%% Functions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Functions}
\begin{ebnf}
CallingConv & \rightarrow "("\; Identifier\; ")" \\
FunctionDeclaration & \rightarrow "def"\; [CallingConv] Identifier\; Identifier\; ["("\; ")" ]\; \\
\end{ebnf}

% Example
\begin{lstlisting}
def main
{
}

def square(x) = x**2;
\end{lstlisting}

calling convention

%% Classes %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Classes}
class
\lstinline!class foo {}!
calling convention
constructor
destructor
operator overloading

%% Traits %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Traits}
trait
\begin{lstlisting}
trait printable
{
	def print(): void;
}

class foo
{
	def print = io.writeln("foo");
}

//class foo can be printable
(foo() as printable).print();
\end{lstlisting}

%% Types Decl %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Enums, Delegates, Alias, Variant}
The type keyword is used to declare utility types, a dis program isn't based on these types but can use them as utility.

\begin{lstlisting}
type myInteger int
type myBoolean = {True, False}
type dgTest def(:int) : bool
type Number = byte | short | int | long | float | double;
\end{lstlisting}


\subsection{Statements}
\subsubsection{for-Statement}
\subsubsection{while-do-Statement}
\subsubsection{try-catch-finally-Statement}
\subsubsection{return-Statement}
\begin{ebnf}
ReturnStatement & \rightarrow "return" Expression \\
\end{ebnf}

\subsubsection{Expression-Statement}
\begin{ebnf}
BlockStatement & \rightarrow {Statement} \\
\end{ebnf}

block

(mixins)

\subsection{Expression}


\subsubsection{Binary-Expression}
\begin{itemize}
\item BinaryOperator: \& | + - * ** / \% \textasciicircum{} 
\item LogicalOperator: \&\&  ||
\end{itemize}

\subsubsection{Unary-Expression}

\subsubsection{if-Expression}
\subsubsection{switch-case-Expression}
\subsubsection{cast-Expression}
\subsubsection{lambda-Expression}
\subsubsection{if-Expression}


